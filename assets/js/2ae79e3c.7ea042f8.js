"use strict";(self.webpackChunkcitros_doc=self.webpackChunkcitros_doc||[]).push([[62102],{3905:(t,e,a)=>{a.d(e,{Zo:()=>m,kt:()=>h});var n=a(67294);function l(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function r(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(t);e&&(n=n.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,n)}return a}function i(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?r(Object(a),!0).forEach((function(e){l(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function s(t,e){if(null==t)return{};var a,n,l=function(t,e){if(null==t)return{};var a,n,l={},r=Object.keys(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||(l[a]=t[a]);return l}(t,e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);for(n=0;n<r.length;n++)a=r[n],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(l[a]=t[a])}return l}var o=n.createContext({}),d=function(t){var e=n.useContext(o),a=e;return t&&(a="function"==typeof t?t(e):i(i({},e),t)),a},m=function(t){var e=d(t.components);return n.createElement(o.Provider,{value:e},t.children)},p="mdxType",u={inlineCode:"code",wrapper:function(t){var e=t.children;return n.createElement(n.Fragment,{},e)}},k=n.forwardRef((function(t,e){var a=t.components,l=t.mdxType,r=t.originalType,o=t.parentName,m=s(t,["components","mdxType","originalType","parentName"]),p=d(a),k=l,h=p["".concat(o,".").concat(k)]||p[k]||u[k]||r;return a?n.createElement(h,i(i({ref:e},m),{},{components:a})):n.createElement(h,i({ref:e},m))}));function h(t,e){var a=arguments,l=e&&e.mdxType;if("string"==typeof t||l){var r=a.length,i=new Array(r);i[0]=k;var s={};for(var o in e)hasOwnProperty.call(e,o)&&(s[o]=e[o]);s.originalType=t,s[p]="string"==typeof t?t:l,i[1]=s;for(var d=2;d<r;d++)i[d]=a[d];return n.createElement.apply(null,i)}return n.createElement.apply(null,a)}k.displayName="MDXCreateElement"},28112:(t,e,a)=>{a.r(e),a.d(e,{assets:()=>o,contentTitle:()=>i,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>d});var n=a(87462),l=(a(67294),a(3905));const r={sidebar_label:"Class Validation",toc_max_heading_level:3,hide_title:!0,description:"Documentation"},i="Class Validation",s={unversionedId:"data_analysis/documentation/validation/validation",id:"version-0.2.53/data_analysis/documentation/validation/validation",title:"Class Validation",description:"Documentation",source:"@site/versioned_docs/version-0.2.53/data_analysis/documentation/validation/validation.md",sourceDirName:"data_analysis/documentation/validation",slug:"/data_analysis/documentation/validation/",permalink:"/docs/data_analysis/documentation/validation/",draft:!1,tags:[],version:"0.2.53",frontMatter:{sidebar_label:"Class Validation",toc_max_heading_level:3,hide_title:!0,description:"Documentation"},sidebar:"gettingStartedSidebar",previous:{title:"Set Multiple Tests",permalink:"/docs/data_analysis/validation/set_multiple_tests"}},o={},d=[{value:"Class <code>Validation</code>",id:"validation.validation.Validation",level:2},{value:"Parameters",id:"parameters",level:4},{value:"Attributes",id:"attributes",level:4},{value:"Method <code>std_bound_test</code>",id:"validation.validation.Validation.std_bound_test",level:2},{value:"Parameters",id:"parameters-1",level:4},{value:"Returns",id:"returns",level:4},{value:"Other Parameters",id:"other-parameters",level:4},{value:"See Also",id:"see-also",level:4},{value:"Method <code>mean_test</code>",id:"validation.validation.Validation.mean_test",level:2},{value:"Parameters",id:"parameters-2",level:4},{value:"Returns",id:"returns-1",level:4},{value:"Method <code>std_test</code>",id:"validation.validation.Validation.std_test",level:2},{value:"Parameters",id:"parameters-3",level:4},{value:"Returns",id:"returns-2",level:4},{value:"Other Parameters",id:"other-parameters-1",level:4},{value:"See Also",id:"see-also-1",level:4},{value:"Method <code>sid_test</code>",id:"validation.validation.Validation.sid_test",level:2},{value:"Parameters",id:"parameters-4",level:4},{value:"Returns",id:"returns-3",level:4},{value:"Method <code>norm_test</code>",id:"validation.validation.Validation.norm_test",level:2},{value:"Parameters",id:"parameters-5",level:4},{value:"Returns",id:"returns-4",level:4},{value:"Method <code>set_tests</code>",id:"validation.validation.Validation.set_tests",level:2},{value:"Parameters",id:"parameters-6",level:4},{value:"Returns",id:"returns-5",level:4},{value:"See Also",id:"see-also-2",level:4}],m={toc:d},p="wrapper";function u(t){let{components:e,...a}=t;return(0,l.kt)(p,(0,n.Z)({},m,a,{components:e,mdxType:"MDXLayout"}),(0,l.kt)("h1",{id:"class-validation"},"Class Validation"),(0,l.kt)("h2",{id:"validation.validation.Validation"},"Class ",(0,l.kt)("inlineCode",{parentName:"h2"},"Validation")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"class Validation(\n    df=None,\n    data_label=None,\n    param_label=None,\n    method='scale',\n    num=100,\n    units='',\n    omit_nan_rows=True,\n    inf_vals=1e+308,\n    log=None\n)\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Description"),(0,l.kt)("p",null,"Validation class."),(0,l.kt)("h4",{id:"parameters"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"df"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"pandas.DataFrame")),(0,l.kt)("td",{parentName:"tr",align:null},"Data table to perform validation tests on.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"data_label"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"str")," or ",(0,l.kt)("strong",{parentName:"td"},"list")," of ",(0,l.kt)("strong",{parentName:"td"},"str")),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies the label(s) of the data column(s) in data table.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"param_label"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"str")),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies the label of the column used to calculate the indices.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"method"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{'scale', 'bin'}"),", default ",(0,l.kt)("inlineCode",{parentName:"td"},"'scale'")),(0,l.kt)("td",{parentName:"tr",align:null},"Method of data preparation: scaling to ","[0,1]"," interval or binning.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"num"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"int"),", default ",(0,l.kt)("strong",{parentName:"td"},"100")),(0,l.kt)("td",{parentName:"tr",align:null},"Number of points in a new scale that will be used for interpolation if the ",(0,l.kt)("strong",{parentName:"td"},"method")," is 'scale'",(0,l.kt)("br",null),"    or number of bins if the ",(0,l.kt)("strong",{parentName:"td"},"method")," is 'bin'.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"units"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"str"),", optional"),(0,l.kt)("td",{parentName:"tr",align:null},"Specifies units of the data.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"omit_nan_rows"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool")),(0,l.kt)("td",{parentName:"tr",align:null},"If True, rows with one or more NaN values will be omitted from the analysis.",(0,l.kt)("br",null),"    If not specified, considered to be True.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"inf_vals"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"None")," or ",(0,l.kt)("strong",{parentName:"td"},"float"),", default ",(0,l.kt)("strong",{parentName:"td"},"1e308")),(0,l.kt)("td",{parentName:"tr",align:null},"If specified, all values from ",(0,l.kt)("strong",{parentName:"td"},"data_label")," column that exceed the provided value in absolute terms",(0,l.kt)("br",null),"    will be treated as NaN values. If this functionality is not required, set inf_vals = None.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"log"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"log : logging.Logger"),", default ",(0,l.kt)("strong",{parentName:"td"},"None")),(0,l.kt)("td",{parentName:"tr",align:null},"Logger to record log. If None, then the new logger is created.")))),(0,l.kt)("h4",{id:"attributes"},"Attributes"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"df"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"pandas.DataFrame")," or ",(0,l.kt)("strong",{parentName:"td"},"None")),(0,l.kt)("td",{parentName:"tr",align:null},"Data table to perform validation tests on.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"db"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/analysis/citros_data#analysis.citros_data.CitrosData",title:"analysis.citros_data.CitrosData"},"CitrosData"))," or ",(0,l.kt)("strong",{parentName:"td"},"None")),(0,l.kt)("td",{parentName:"tr",align:null},"CitrosData object after binning or scaling.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"stat"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/analysis/citros_stat#analysis.citros_stat.CitrosStat",title:"analysis.citros_stat.CitrosStat"},"CitrosStat"))," or ",(0,l.kt)("strong",{parentName:"td"},"None")),(0,l.kt)("td",{parentName:"tr",align:null},"CitrosStat object that stores mean, standard deviation and covariance matrix as attributes."))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Examples"),(0,l.kt)("p",null,"Import Validation and CitrosDB:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> from citros import CitrosDB, Validation\n")),(0,l.kt)("p",null,"From the batch 'albedo' of the simulation 'planetary_nebula' from the json-data column of the topic 'A'\ndownload simulated data labeled as 'data.x.x_1' and column with time 'data.time'."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> citros = CitrosDB(simulation = 'planetary_nebula', batch = 'albedo')\n>>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x.x_1','data.time'])\n>>> print(df)\n    sid   rid   time        topic   type   data.x.x_1   data.time\n0   1     0     312751159   A       a      0.000        10.0\n1   1     1     407264008   A       a      0.008        17.9\n2   1     2     951279608   A       a      0.016        20.3\n")),(0,l.kt)("p",null,"Set 'data.time' as independent variable and 'data.x.x_1' as dependent one.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'bin' - bins values of column ",(0,l.kt)("strong",{parentName:"p"},"param_label")," in ",(0,l.kt)("strong",{parentName:"p"},"num")," intervals,\nset index to each of the interval, group data according to the binning and calculate mean data values for each group."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> V = Validation(df, data_label = ['data.x.x_1'], param_label = 'data.time',\n...                method = 'bin', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"For topic 'A' download 3-dimensional json-data 'data.x' that contains 'data.x.x_1', 'data.x.x_2' and 'data.x.x_3' columns,\nand column with time 'data.time'."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x','data.time'])\n>>> print(df['data.x'])\n0          {'x_1': 0.0, 'x_2': 0.08, 'x_3': 0.047}\n1       {'x_1': 0.008, 'x_2': 0.08, 'x_3': -0.003}\n2      {'x_1': 0.016, 'x_2': 0.078, 'x_3': -0.034}\n...\n")),(0,l.kt)("p",null,"Set 'data.time' as independent variable and 'data.x' as dependent vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'scale' - scales parameter ",(0,l.kt)("strong",{parentName:"p"},"param_label")," for each of the 'sid' to ","[0, 1]"," interval\nand interpolate data on the new scale."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> V = Validation(df, data_label = 'data.x', param_label = 'data.time',\n...                method = 'scale', num = 50, units = 'm')\n"))),(0,l.kt)("h2",{id:"validation.validation.Validation.std_bound_test"},"Method ",(0,l.kt)("inlineCode",{parentName:"h2"},"std_bound_test")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def std_bound_test(\n    limits=1.0,\n    n_std=3,\n    nan_passed=True,\n    std_color='b',\n    connect_nan_std=False,\n    std_area=False,\n    std_lines=True\n)\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Description"),(0,l.kt)("p",null,"Test whether ",(0,l.kt)("strong",{parentName:"p"},"n_std"),"-standard deviation boundary is within the given limits."),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dictionary with summary of the test results, with the following structure:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"{\n'test_param' : list,          # initial tests parameters\ncolumn_name:                  # label of the column, str\n    {'passed' : bool},        # if the tests was passed or not\n    {'pass_rate' : float},    # fraction of the points that pass the test\n    {'failed' : \n        {x_index: x_value}},  # indexes and values of the x coordinate of \n                              #   the points that fail the test {int: float} \n    {'nan_std' :\n        {x_index: x_value}}   # indexes and values of the x coordinate of the points\n}                             #   that have NaN (Not a Number) values for standard deviation\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"table that provides test results for each standard deviation boundary point,\nusing a boolean value to indicate whether it passed or failed the test;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"figure with plotted simulations, mean values, standard deviation boundaries and limit boundaries;"))),(0,l.kt)("h4",{id:"parameters-1"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"limits"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"float")," or ",(0,l.kt)("strong",{parentName:"td"},"list"),", default ",(0,l.kt)("strong",{parentName:"td"},"1.0")),(0,l.kt)("td",{parentName:"tr",align:null},"Limit to test standard deviation boundary. Limits may be set as:",(0,l.kt)("br",null),"      ","\u2022"," one value and it will be treated as an +- interval: value -> ","[-value, value]",";",(0,l.kt)("br",null),"      ","\u2022"," list of lower and upper limits: ","[lower_limit, upper_limit]",";",(0,l.kt)("br",null),"      ","\u2022"," If the data has multiple columns, limits may be set for each of the column.",(0,l.kt)("br",null),"    That way list length must be equal to number of columns. For example, for the 3-dimensional vector with corresponding standard deviation boundaries ","[std_bound_1, std_bound_2, std_bound_3]",":",(0,l.kt)("br",null),"    [","[",(0,l.kt)("strong",{parentName:"td"},"limit_lower"),", ",(0,l.kt)("strong",{parentName:"td"},"limit_upper"),"]",", ",(0,l.kt)("strong",{parentName:"td"},"value_1"),", ",(0,l.kt)("strong",{parentName:"td"},"value_2"),"] will be processed as: ",(0,l.kt)("br",null),"    ",(0,l.kt)("strong",{parentName:"td"},"limit_lower")," < std_bound_1 < ",(0,l.kt)("strong",{parentName:"td"},"limit_upper"),",",(0,l.kt)("br",null),"    -",(0,l.kt)("strong",{parentName:"td"},"value_1")," < std_bound_2 < ",(0,l.kt)("strong",{parentName:"td"},"value_1"),",",(0,l.kt)("br",null),"    -",(0,l.kt)("strong",{parentName:"td"},"value_2")," < std_bound_2 < ",(0,l.kt)("strong",{parentName:"td"},"value_2"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"n_std"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"int"),", default ",(0,l.kt)("strong",{parentName:"td"},"3")),(0,l.kt)("td",{parentName:"tr",align:null},"The parameter specifies the number of standard deviations to be within limits.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"nan_passed"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"True")),(0,l.kt)("td",{parentName:"tr",align:null},"If True, the NaN values of standard deviation will pass the test.")))),(0,l.kt)("h4",{id:"returns"},"Returns"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"log"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/access/citros_dict#access.citros_dict.CitrosDict",title:"access.citros_dict.CitrosDict"},"CitrosDict"))),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with validation test results.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"table"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"pandas.DataFrame")),(0,l.kt)("td",{parentName:"tr",align:null},"Table with test results for each of the standard deviation boundary point, indicating whether it passes or fails the test.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"fig"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"matplotlib.figure.Figure")),(0,l.kt)("td",{parentName:"tr",align:null},"Figure with plotted simulations, mean values, standard deviation boundaries and limit boundaries.")))),(0,l.kt)("h4",{id:"other-parameters"},"Other Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"std_color"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"str"),", default ",(0,l.kt)("inlineCode",{parentName:"td"},"'b'")),(0,l.kt)("td",{parentName:"tr",align:null},"Color for displaying standard deviations, blue by default.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"connect_nan_std"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"False")),(0,l.kt)("td",{parentName:"tr",align:null},"If True, all non-NaN values in standard deviation boundary line are connected, resulting in a continuous line. ",(0,l.kt)("br",null),"    Otherwise, breaks are introduced in the standard deviation line whenever NaN values are encountered.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"std_area"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"False")),(0,l.kt)("td",{parentName:"tr",align:null},"Fill area within ",(0,l.kt)("strong",{parentName:"td"},"n_std"),"-standard deviation lines with color.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"std_lines"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"True")),(0,l.kt)("td",{parentName:"tr",align:null},"If False, remove standard deviation boundary lines.")))),(0,l.kt)("h4",{id:"see-also"},"See Also"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"pandas.DataFrame"),", ",(0,l.kt)("strong",{parentName:"p"},"pandas.Series"))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Examples"),(0,l.kt)("p",null,"Import Validation and CitrosDB:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> from citros import CitrosDB, Validation\n")),(0,l.kt)("p",null,"From the batch 'density' of the simulation 'diffuse_nebula' from the topic 'A' download 2 columns of the simulated data\nlabeled 'data.x.x_1' and 'data.x.x_2' and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x.x_1' and 'data.x.x_2' as dependent 2-dimensional vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'bin' - bins values of column ",(0,l.kt)("strong",{parentName:"p"},"param_label")," in ",(0,l.kt)("strong",{parentName:"p"},"num")," intervals,\nset index to each of the interval, group data according to the binning and calculate mean data values for each group."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> citros = CitrosDB(simulation = 'diffuse_nebula', batch = 'density')\n>>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'})\\\n...                       .data(['data.x.x_1','data.x.x_2','data.time'])\n>>> V = Validation(df, data_label = ['data.x.x_1', 'data.x.x_2'], param_label = 'data.time', \n...                method = 'bin', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Test whether 3-sigma standard deviation boundary is within interval ","[-0.3, 0.3]"," (treat nan values of the\nstandard deviation, if they exist, as passing the test):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.std_bound_test(limits = 0.3, n_std = 3, nan_passed = True)\n>>> log.print()\nstd_bound_test: passed\n{\n 'test_param': {\n   'limits': 0.3,\n   'n_std': 3,\n   'nan_passed': True\n },\n 'data.x.x_1': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   },\n   'nan_std': {\n     49: 807.942\n   }\n },\n 'data.x.x_2': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   },\n   'nan_std': {\n     49: 807.942\n   }\n }\n}\n")),(0,l.kt)("p",null,"The same, but set limit interval to be ","[-1, 0.3]",":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.std_bound_test(limits = [-1, 0.3], n_std = 3, nan_passed = True)\nstd_bound_test: passed\n")),(0,l.kt)("p",null,"Set different limits for 1-sigma standard deviation boundaries of 2-dimensional vector: for the first\nelement of the vector boundaries should be within interval ","[-1, 2]"," and for the second one - ","[-0.5, 0.5]",":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.std_bound_test(limits = [[-1, 2], 0.5], n_std = 1)\nstd_bound_test: passed\n")),(0,l.kt)("p",null,"The same as in the previous example, but limits should be ","[-1, 1]"," for the first element of the vector\nand ","[-0.5, 0.5]"," for the second. In this case limits should be set as [","[-1, 1]",", ","[-0.5, 0.5]","] and not as ","[1, 0.5]",",\nbecause in the latter case limits will be treated as a common boundary for both elements."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.std_bound_test(limits = [[-1, 1], [-0.5, 0.5]], n_std = 1)\nstd_bound_test: passed\n")),(0,l.kt)("p",null,"Download 3-dimensional json-data 'data.x' that contains 'data.x.x_1', 'data.x.x_2' and 'data.x.x_3' columns, and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x' as dependent vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'scale' - scales parameter ",(0,l.kt)("strong",{parentName:"p"},"param_label")," for each of the 'sid' to ","[0, 1]"," interval\nand interpolate data on the new scale."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x','data.time'])\n>>> V3 = Validation(df, data_label = 'data.x', param_label = 'data.time', \n...                 method = 'scale', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Set different limits on 3-dimensional vector: ","[-0.5, 0.5]"," for the first element, ","[-1.5, 1.5]"," for the second,\n","[-20, 10]"," for the third:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V3.std_bound_test(limits = [0.5, 1.5, [-20, 10]], n_std = 3)\nstd_bound_test: passed\n"))),(0,l.kt)("h2",{id:"validation.validation.Validation.mean_test"},"Method ",(0,l.kt)("inlineCode",{parentName:"h2"},"mean_test")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def mean_test(\n    limits=1.0,\n    nan_passed=True\n)\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Description"),(0,l.kt)("p",null,"Test whether mean is within the given limits."),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dictionary with summary of the test results, with the following structure:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"{\n'test_param' : list,          # initial tests parameters\ncolumn_name:                  # label of the column, str\n    {'passed' : bool},        # if the tests was passed or not.\n    {'pass_rate' : float},    # fraction of the points that pass the test\n    {'failed' : \n        {x_index: x_value}},  # indexes and values of the x coordinate of the \n}                             #   points that fail the test {int: float}   \n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"table that provides test results for each of the mean point,\nusing a boolean value to indicate whether it passed or failed the test;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"figure with plotted simulations, mean values and limit boundaries."))),(0,l.kt)("h4",{id:"parameters-2"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"limits"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"float")," or ",(0,l.kt)("strong",{parentName:"td"},"list"),", default ",(0,l.kt)("strong",{parentName:"td"},"1.0")),(0,l.kt)("td",{parentName:"tr",align:null},"Limit to test mean. Limits may be set as:",(0,l.kt)("br",null),"      ","\u2022"," one value and it will be treated as an +- interval: value -> ","[-value, value]",";",(0,l.kt)("br",null),"      ","\u2022"," list of lower and upper limits: ","[lower_limit, upper_limit]",";",(0,l.kt)("br",null),"      ","\u2022"," If the data has multiple columns, limits may be set for each of the column.",(0,l.kt)("br",null),"    That way list length must be equal to number of columns. For example, for the 3-dimensional vector with corresponding mean vector ","[mean_1, mean_2, mean_3]",":",(0,l.kt)("br",null),"    [","[",(0,l.kt)("strong",{parentName:"td"},"limit_lower"),", ",(0,l.kt)("strong",{parentName:"td"},"limit_upper"),"]",", ",(0,l.kt)("strong",{parentName:"td"},"value_1"),", ",(0,l.kt)("strong",{parentName:"td"},"value_2"),"] will be processed as: ",(0,l.kt)("br",null),"    ",(0,l.kt)("strong",{parentName:"td"},"limit_lower")," < mean_1 < ",(0,l.kt)("strong",{parentName:"td"},"limit_upper"),",",(0,l.kt)("br",null),"    -",(0,l.kt)("strong",{parentName:"td"},"value_1")," < mean_2 < ",(0,l.kt)("strong",{parentName:"td"},"value_1"),",",(0,l.kt)("br",null),"    -",(0,l.kt)("strong",{parentName:"td"},"value_2")," < mean_2 < ",(0,l.kt)("strong",{parentName:"td"},"value_2"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"nan_passed"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"True")),(0,l.kt)("td",{parentName:"tr",align:null},"If True, the NaN values of the mean will pass the test.")))),(0,l.kt)("h4",{id:"returns-1"},"Returns"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"log"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/access/citros_dict#access.citros_dict.CitrosDict",title:"access.citros_dict.CitrosDict"},"CitrosDict"))),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with validation test results.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"table"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"pandas.DataFrame")),(0,l.kt)("td",{parentName:"tr",align:null},"Table with test results for each of the mean point, indicating whether it passes or fails the test.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"fig"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"matplotlib.figure.Figure")),(0,l.kt)("td",{parentName:"tr",align:null},"Figure with plotted simulations, mean values and limit boundaries."))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Examples"),(0,l.kt)("p",null,"Import Validation and CitrosDB:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> from citros import CitrosDB, Validation\n")),(0,l.kt)("p",null,"From the batch 'density' of the simulation 'diffuse_nebula' from the topic 'A' download 2 columns of the simulated data\nlabeled 'data.x.x_1' and 'data.x.x_2' and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x.x_1' and 'data.x.x_2' as dependent 2-dimensional vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'bin' - bins values of column ",(0,l.kt)("strong",{parentName:"p"},"param_label")," in ",(0,l.kt)("strong",{parentName:"p"},"num")," intervals,\nset index to each of the interval, group data according to the binning and calculate mean data values for each group."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> citros = CitrosDB(simulation = 'diffuse_nebula', batch = 'density')\n>>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'})\\\n...                       .data(['data.x.x_1','data.x.x_2','data.time'])\n>>> V = Validation(df, data_label = ['data.x.x_1', 'data.x.x_2'], param_label = 'data.time', \n...                method = 'bin', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Test whether mean values are is within the  interval ","[-10, 10]",":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.mean_test(limits = 10)\n>>> log.print()\nmean_test: passed\n{\n 'test_param': {\n   'limits': 10\n },\n 'data.x.x_1': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   }\n },\n 'data.x.x_2': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   }\n }\n}\n")),(0,l.kt)("p",null,"The same, but set limit interval to be ","[-0.5, 0.8]",":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.mean_test(limits = [-0.5, 0.8])\nmean_test: passed\n")),(0,l.kt)("p",null,"Set different limits on mean values for each of the 1-dimensional element of the 2-dimensional vector:\n","[-0.05, 0.08]"," for the first element and ","[-0.5, 0.5]"," for the second:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.mean_test(limits = [[-0.05, 0.08], 0.5])\nmean_test: passed\n")),(0,l.kt)("p",null,"The same as in the previous example, but limits should be ","[-1, 1]"," for the first element of the vector\nand ","[-0.5, 0.5]"," for the second. In this case limits should be set as [","[-1, 1]",", ","[-0.5, 0.5]","] and not as ","[1, 0.5]",",\nbecause in the latter case limits will be treated as a common boundary for both elements."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.mean_test(limits = [[-1, 1], [-0.5, 0.5]])\nmean_test: passed\n")),(0,l.kt)("p",null,"Download 3-dimensional json-data 'data.x' that contains 'data.x.x_1', 'data.x.x_2' and 'data.x.x_3' columns, and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x' as dependent vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'scale' - scales parameter ",(0,l.kt)("strong",{parentName:"p"},"param_label")," for each of the 'sid' to ","[0, 1]"," interval\nand interpolate data on the new scale."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x','data.time'])\n>>> V3 = Validation(df, data_label = 'data.x', param_label = 'data.time', \n...                 method = 'scale', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Set different limits on 3-dimensional vector: ","[-0.5, 0.5]"," for the first element, ","[-1.5, 1.5]"," for the second,\n","[-20, 10]"," for the third:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V3.mean_test(limits = [0.5, 1.5, [-20, 10]])\nmean_test: passed\n"))),(0,l.kt)("h2",{id:"validation.validation.Validation.std_test"},"Method ",(0,l.kt)("inlineCode",{parentName:"h2"},"std_test")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def std_test(\n    limits=1.0,\n    n_std=3,\n    nan_passed=True,\n    std_color='b',\n    connect_nan_std=False,\n    std_area=False,\n    std_lines=True\n)\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Description"),(0,l.kt)("p",null,"Test whether ",(0,l.kt)("strong",{parentName:"p"},"n_std"),"-standard deviation does not exceed the given limits."),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dictionary with summary of the test results, with the following structure:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"{\n'test_param' : list,          # initial tests parameters\ncolumn_name:                  # label of the column, str\n    {'passed' : bool},        # if the tests was passed or not\n    {'pass_rate' : float},    # fraction of the points that pass the test\n    {'failed' : \n        {x_index: x_value}},  # indexes and values of the x coordinate of \n                              #   the points that fail the test {int: float} \n    {'nan_std' :\n        {x_index: x_value}}   # indexes and values of the x coordinate of the points\n}                             #   that have NaN (Not a Number) values for standard deviation\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"table that provides test results for each standard deviation point,\nusing a boolean value to indicate whether it passed or failed the test.")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"figure with standard deviations and limit boundaries."))),(0,l.kt)("h4",{id:"parameters-3"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"limits"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"float")," or ",(0,l.kt)("strong",{parentName:"td"},"list"),", default ",(0,l.kt)("strong",{parentName:"td"},"1.0")),(0,l.kt)("td",{parentName:"tr",align:null},"Limit to test standard deviation. Limits may be set as:",(0,l.kt)("br",null),"      ","\u2022"," one value;",(0,l.kt)("br",null),"      ","\u2022"," If the data has multiple columns, limits may be set for each of the column.",(0,l.kt)("br",null),"    That way list length must be equal to number of columns. ",(0,l.kt)("br",null),"    For example, in case of 3-dimensional vector with corresponding standard deviation vector = ","[std_1, std_2, std_3]",", limits = ","[",(0,l.kt)("strong",{parentName:"td"},"value_1"),", ",(0,l.kt)("strong",{parentName:"td"},"value_2"),", ",(0,l.kt)("strong",{parentName:"td"},"value_3"),"]"," will be processed as:",(0,l.kt)("br",null),"    std_1 < ",(0,l.kt)("strong",{parentName:"td"},"value_1"),",",(0,l.kt)("br",null),"    std_2 < ",(0,l.kt)("strong",{parentName:"td"},"value_2"),",",(0,l.kt)("br",null),"    std_2 < ",(0,l.kt)("strong",{parentName:"td"},"value_3"),".")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"n_std"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"int"),", default ",(0,l.kt)("strong",{parentName:"td"},"3")),(0,l.kt)("td",{parentName:"tr",align:null},"The parameter specifies the number of standard deviations to be less then limits.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"nan_passed"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"True")),(0,l.kt)("td",{parentName:"tr",align:null},"If True, the NaN values of standard deviation will pass the test.")))),(0,l.kt)("h4",{id:"returns-2"},"Returns"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"log"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/access/citros_dict#access.citros_dict.CitrosDict",title:"access.citros_dict.CitrosDict"},"CitrosDict"))),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with validation test results.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"table"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"pandas.DataFrame")),(0,l.kt)("td",{parentName:"tr",align:null},"Table with test results for each of the standard deviation point, indicating whether it passes or fails the test.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"fig"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"matplotlib.figure.Figure")),(0,l.kt)("td",{parentName:"tr",align:null},"Figure with standard deviations and limit boundaries.")))),(0,l.kt)("h4",{id:"other-parameters-1"},"Other Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"std_color"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"str"),", default ",(0,l.kt)("inlineCode",{parentName:"td"},"'b'")),(0,l.kt)("td",{parentName:"tr",align:null},"Color for displaying standard deviation, blue by default.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"connect_nan_std"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"False")),(0,l.kt)("td",{parentName:"tr",align:null},"If True, all non-NaN values in standard deviation line are connected, resulting in a continuous line. ",(0,l.kt)("br",null),"    Otherwise, breaks are introduced in the standard deviation line whenever NaN values are encountered.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"std_area"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"False")),(0,l.kt)("td",{parentName:"tr",align:null},"Fill area within ",(0,l.kt)("strong",{parentName:"td"},"n_std"),"-standard deviation line with color.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"std_lines"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"True")),(0,l.kt)("td",{parentName:"tr",align:null},"If False, remove standard deviation line.")))),(0,l.kt)("h4",{id:"see-also-1"},"See Also"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},"pandas.DataFrame"),", ",(0,l.kt)("strong",{parentName:"p"},"pandas.Series"))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Examples"),(0,l.kt)("p",null,"Import Validation and CitrosDB:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> from citros import CitrosDB, Validation\n")),(0,l.kt)("p",null,"From the batch 'density' of the simulation 'diffuse_nebula' from the topic 'A' download 2 columns of the simulated data\nlabeled 'data.x.x_1' and 'data.x.x_2' and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x.x_1' and 'data.x.x_2' as dependent 2-dimensional vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'bin' - bins values of column ",(0,l.kt)("strong",{parentName:"p"},"param_label")," in ",(0,l.kt)("strong",{parentName:"p"},"num")," intervals,\nset index to each of the interval, group data according to the binning and calculate mean data values for each group."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> citros = CitrosDB(simulation = 'diffuse_nebula', batch = 'density')\n>>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'})\\\n...                       .data(['data.x.x_1','data.x.x_2','data.time'])\n>>> V = Validation(df, data_label = ['data.x.x_1', 'data.x.x_2'], param_label = 'data.time', \n...                method = 'bin', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Test whether 3-sigma standard deviation is within interval ","[-0.3, 0.3]"," (treat nan values of the\nstandard deviation, if they exist, as passing the test):"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.std_test(limits = 1.5, n_std = 3, nan_passed = True)\n>>> log.print()\nstd_bound_test: passed\n{\n 'test_param': {\n   'limits': 0.3,\n   'n_std': 3,\n   'nan_passed': True\n },\n 'data.x.x_1': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   },\n   'nan_std': {\n     49: 807.942\n   }\n },\n 'data.x.x_2': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   },\n   'nan_std': {\n     49: 807.942\n   }\n }\n}\n")),(0,l.kt)("p",null,"Download 3-dimensional json-data 'data.x' that contains 'data.x.x_1', 'data.x.x_2' and 'data.x.x_3' columns, and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x' as dependent vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'scale' - scales parameter ",(0,l.kt)("strong",{parentName:"p"},"param_label")," for each of the 'sid' to ","[0, 1]"," interval\nand interpolate data on the new scale."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x','data.time'])\n>>> V3 = Validation(df, data_label = 'data.x', param_label = 'data.time', \n...                 method = 'scale', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Set different limits on 3-dimensional vector: 1.5 for the first element, 1.5 for the second,\n30 for the third:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V3.std_test(limits = [1.5, 1.5, 30], n_std = 3)\nstd_test: passed\n"))),(0,l.kt)("h2",{id:"validation.validation.Validation.sid_test"},"Method ",(0,l.kt)("inlineCode",{parentName:"h2"},"sid_test")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def sid_test(\n    limits=1.0,\n    nan_passed=True\n)\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Description"),(0,l.kt)("p",null,"Test whether all simulations are within the given limits."),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dictionary with summary of the test results, with the following structure:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"{\n'test_param' : list,                # initial tests parameters\ncolumn_name:                        # label of the column, str\n    {'passed' : bool},              # if the tests was passed or not.\n    {'pass_rate' : \n        {'sid_fraction' : float},   # fraction of simulations that pass the test\n        {sid : fraction}},          # fraction of the points that pass the test for each simulation {int: float}\n    {'failed' : \n        {sid :                      # id of the simulation that contains points that failed the test\n            {x_index: x_value}}},   # indexes and values of the x coordinate of the points \n}                                   #   that fail the test {int: {int: float}}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"table that provides test results for for each point of the simulations,\nusing a boolean value to indicate whether it passed or failed the test;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"figure with plotted simulations, mean values and limit boundaries."))),(0,l.kt)("h4",{id:"parameters-4"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"limits"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"float")," or ",(0,l.kt)("strong",{parentName:"td"},"list"),", default ",(0,l.kt)("strong",{parentName:"td"},"1.0")),(0,l.kt)("td",{parentName:"tr",align:null},"Limit to test simulation results. Limits may be set as:",(0,l.kt)("br",null),"      ","\u2022"," one value and it will be treated as an +- interval: value -> ","[-value, value]",";",(0,l.kt)("br",null),"      ","\u2022"," list of lower and upper limits: ","[lower_limit, upper_limit]",";",(0,l.kt)("br",null),"      ","\u2022"," If the data has multiple columns, limits may be set for each of the column.",(0,l.kt)("br",null),"    That way list length must be equal to number of columns. For example, for the 3-dimensional vector that contains v1, v2, v3 columns and numbers N simulations:",(0,l.kt)("br",null),"    [","[",(0,l.kt)("strong",{parentName:"td"},"limit_lower"),", ",(0,l.kt)("strong",{parentName:"td"},"limit_upper"),"]",", ",(0,l.kt)("strong",{parentName:"td"},"value_1"),", ",(0,l.kt)("strong",{parentName:"td"},"value_2"),"] will be processed as: ",(0,l.kt)("br",null),"    ",(0,l.kt)("strong",{parentName:"td"},"limit_lower")," < v1 < ",(0,l.kt)("strong",{parentName:"td"},"limit_upper"),", ",(0,l.kt)("br",null),"    -",(0,l.kt)("strong",{parentName:"td"},"value_1")," < v2 < ",(0,l.kt)("strong",{parentName:"td"},"value_1"),", ",(0,l.kt)("br",null),"    -",(0,l.kt)("strong",{parentName:"td"},"value_2")," < v3 < ",(0,l.kt)("strong",{parentName:"td"},"value_2")," for each of the N simulations.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"nan_passed"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"bool"),", default ",(0,l.kt)("strong",{parentName:"td"},"True")),(0,l.kt)("td",{parentName:"tr",align:null},"If True, the NaN values will pass the test.")))),(0,l.kt)("h4",{id:"returns-3"},"Returns"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"log"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/access/citros_dict#access.citros_dict.CitrosDict",title:"access.citros_dict.CitrosDict"},"CitrosDict"))),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with validation test results.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"table"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"pandas.DataFrame")),(0,l.kt)("td",{parentName:"tr",align:null},"Table with test results for each point of the simulations, indicating whether it passes or fails the test.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"fig"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"matplotlib.figure.Figure")),(0,l.kt)("td",{parentName:"tr",align:null},"Figure with plotted simulations, mean values and limit boundaries."))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Examples"),(0,l.kt)("p",null,"Import Validation and CitrosDB:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> from citros import CitrosDB, Validation\n")),(0,l.kt)("p",null,"From the batch 'density' of the simulation 'diffuse_nebula' from the topic 'A' download 2 columns of the simulated data\nlabeled 'data.x.x_1' and 'data.x.x_2' and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x.x_1' and 'data.x.x_2' as dependent 2-dimensional vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'bin' - bins values of column ",(0,l.kt)("strong",{parentName:"p"},"param_label")," in ",(0,l.kt)("strong",{parentName:"p"},"num")," intervals,\nset index to each of the interval, group data according to the binning and calculate mean data values for each group."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> citros = CitrosDB(simulation = 'diffuse_nebula', batch = 'density')\n>>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'})\\\n                          .data(['data.x.x_1','data.x.x_2','data.time'])\n>>> V = Validation(df, data_label = ['data.x.x_1', 'data.x.x_2'], param_label = 'data.time', \n...                method = 'bin', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Test whether all simulations are is within the interval ","[-10, 10]",":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.sid_test(limits = 10)\n>>> log.print()\nsid_test: passed\n{\n 'test_param': {\n   'limits': 10\n },\n 'data.x.x_1': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   }\n },\n 'data.x.x_2': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   }\n }\n}\n")),(0,l.kt)("p",null,"The same, but set limit interval to be ","[-0.5, 0.8]",":"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.sid_test(limits = [-0.5, 0.8])\nsid_test: passed\n")),(0,l.kt)("p",null,"Set different limits on mean values for each of the 1-dimensional element of the 2-dimensional vector:\n","[-0.05, 0.08]"," for the first element and ","[-0.5, 0.5]"," for the second:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.sid_test(limits = [[-0.05, 0.08], 0.5])\nsid_test: passed\n")),(0,l.kt)("p",null,"The same as in the previous example, but limits should be ","[-1, 1]"," for the first element of the vector\nand ","[-0.5, 0.5]"," for the second. In this case limits should be set as [","[-1, 1]",", ","[-0.5, 0.5]","] and not as ","[1, 0.5]",",\nbecause in the latter case limits will be treated as a common boundary for both elements."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.sid_test(limits = [[-1, 1], [-0.5, 0.5]])\nsid_test: passed\n")),(0,l.kt)("p",null,"For topic 'A' download 3-dimensional json-data 'data.x' that contains 'data.x.x_1', 'data.x.x_2' and 'data.x.x_3' columns, and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x' as dependent vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'scale' - scales parameter ",(0,l.kt)("strong",{parentName:"p"},"param_label")," for each of the 'sid' to ","[0, 1]"," interval\nand interpolate data on the new scale."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x','data.time'])\n>>> V3 = Validation(df, data_label = 'data.x', param_label = 'data.time', \n...                 method = 'scale', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Set different limits on 3-dimensional vector: ","[-0.5, 0.5]"," for the first element, ","[-1.5, 1.5]"," for the second one, an\n","[-20, 10]"," for the third vector element:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V3.sid_test(limits = [0.5, 1.5, [-20, 10]])\nsid_test: passed\n"))),(0,l.kt)("h2",{id:"validation.validation.Validation.norm_test"},"Method ",(0,l.kt)("inlineCode",{parentName:"h2"},"norm_test")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def norm_test(\n    norm_type='L2',\n    limits=1.0\n)\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Description"),(0,l.kt)("p",null,"Test whether norm of the each simulation is less than the given limit."),(0,l.kt)("p",null,"The output is:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"dictionary with summary of the test results, with the following structure:")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"{\n'test_param' : list,                # initial tests parameters\ncolumn_name :                       # label of the column, str\n    {'passed' : bool},              # if the tests was passed or not.\n    {'pass_rate' : float}           # fraction of the simulations that pass the test\n    {'norm_value' :\n        {sid: value}},              # norm for each of the simulation {int: float}\n    {'failed' : list}               # sid that fail the test\n}\n")),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"table that provides test results for each simulation,\nusing a boolean value to indicate whether it passed or failed the test;")),(0,l.kt)("li",{parentName:"ul"},(0,l.kt)("p",{parentName:"li"},"figure with plotted norm value and limits."))),(0,l.kt)("h4",{id:"parameters-5"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"norm_type"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("inlineCode",{parentName:"td"},"{'L2', 'Linf'}"),", default ",(0,l.kt)("inlineCode",{parentName:"td"},"'L2'")),(0,l.kt)("td",{parentName:"tr",align:null},"Norm type. Norm is calculated for each of the simulation. If data is a multidimensional vector, it is calculated",(0,l.kt)("br",null),"    for each simulation of the each vector element.",(0,l.kt)("br",null),"    Type of the norm:",(0,l.kt)("br",null),"      ","\u2022"," 'L2' - Euclidean norm, square root of the sum of the squares.",(0,l.kt)("br",null),"      ","\u2022"," 'Linf' - absolute maximum.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"limits"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"float")," or ",(0,l.kt)("strong",{parentName:"td"},"list"),", default ",(0,l.kt)("strong",{parentName:"td"},"1.0")),(0,l.kt)("td",{parentName:"tr",align:null},"Limits on the simulation norm. Limits may be set as:",(0,l.kt)("br",null),"      ","\u2022"," one value;",(0,l.kt)("br",null),"      ","\u2022"," if the data has multiple columns, limits may be set for each of the column separately as a list.",(0,l.kt)("br",null),"    That way list length must be equal to number of the columns.")))),(0,l.kt)("h4",{id:"returns-4"},"Returns"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"log"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/access/citros_dict#access.citros_dict.CitrosDict",title:"access.citros_dict.CitrosDict"},"CitrosDict"))),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with validation test results.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"table"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"pandas.DataFrame")),(0,l.kt)("td",{parentName:"tr",align:null},"Table with test results for each simulation, indicating whether it passes or fails the test.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"fig"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"matplotlib.figure.Figure")),(0,l.kt)("td",{parentName:"tr",align:null},"Figure with plotted norm value and limits."))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Examples"),(0,l.kt)("p",null,"Import Validation and CitrosDB:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> from citros import CitrosDB, Validation\n")),(0,l.kt)("p",null,"From the batch 'density' of the simulation 'diffuse_nebula' from the topic 'A' download 1 columns of the simulated data\nlabeled 'data.x.x_1' and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x.x_1' as a dependent one.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'bin' - bins values of column ",(0,l.kt)("strong",{parentName:"p"},"param_label")," in ",(0,l.kt)("strong",{parentName:"p"},"num")," intervals,\nset index to each of the interval, group data according to the binning and calculate mean data values for each group."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> citros = CitrosDB(simulation = 'diffuse_nebula', batch = 'density')\n>>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x.x_1','data.time'])\n>>> V = Validation(df, data_label = 'data.x.x_1', param_label = 'data.time',\n...                method = 'bin', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Test whether L2 norm for each of the simulation does not exceed 1:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V.norm_test(norm_type = 'L2', limits = 1)\n>>> log.print()\n>>> print(table)\nnorm_test L2: passed\n{\n 'test_param': {\n   'limits': 1\n },\n 'data.x.x_1': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'norm_value': {\n     1: 0.39,\n     2: 0.39,\n     3: 0.38\n   },\n   'failed': []\n },\n}\n>>> print(table)\n     data.x.x_1\nsid\n1          True\n2          True\n3          True\n")),(0,l.kt)("p",null,"Download 3-dimensional json-data 'data.x' that contains 'data.x.x_1', 'data.x.x_2' and 'data.x.x_3' columns, and column with time 'data.time'.\nSet 'data.time' as independent variable and 'data.x' as dependent vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'scale' - scales parameter ",(0,l.kt)("strong",{parentName:"p"},"param_label")," for each of the 'sid' to ","[0, 1]"," interval\nand interpolate data on the new scale."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x','data.time'])\n>>> V3 = Validation(df, data_label = 'data.x', param_label = 'data.time',\n...                method = 'scale', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Set different limits on Linf norm for each of the element of the 3-dimensional vector: 1.0 for the first element,\n0.1 for the second one, and 0.5 for the third vector element:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> log, table, fig = V3.norm_test(norm_type = 'Linf', limits = [1.0, 0.1, 0.5])\nnorm_test Linf: passed\n"))),(0,l.kt)("h2",{id:"validation.validation.Validation.set_tests"},"Method ",(0,l.kt)("inlineCode",{parentName:"h2"},"set_tests")),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},"def set_tests(\n    test_method={'std_bound': {'limits': 1.0, 'n_std': 3, 'nan_passed': True}, 'mean': {'limits': 1.0, 'nan_passed': True}, 'sid': {'limits': 1.0, 'nan_passed': True}, 'norm_L2': {'limits': 1.0}, 'norm_Linf': {'limits': 1.0}}\n)\n")),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Description"),(0,l.kt)("p",null,"Perform tests on the data."),(0,l.kt)("p",null,"Possible test methods are:"),(0,l.kt)("details",null,(0,l.kt)("summary",null,"'std_bound'"),(0,l.kt)("p",null,"Test whether standard deviation is within the given limits.\nTest parameters are stored as the dict with the following keys:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"'limits' : float or list, default 1.0\nLimit to test standard deviation boundary. Limits may be set as:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"one value and it will be treated as an +- interval: value -> ","[-value, value]",";"),(0,l.kt)("li",{parentName:"ul"},"list of lower and upper limits: ","[lower_limit, upper_limit]",";"),(0,l.kt)("li",{parentName:"ul"},"If the data has multiple columns, limits may be set for each of the column.\nThat way list length must be equal to number of columns. For example, for the 3-dimensional vector with corresponding standard deviation boundaries ","[std_bound_1, std_bound_2, std_bound_3]",":\n[","[",(0,l.kt)("strong",{parentName:"li"},"limit_lower"),", ",(0,l.kt)("strong",{parentName:"li"},"limit_upper"),"]",", ",(0,l.kt)("strong",{parentName:"li"},"value_1"),", ",(0,l.kt)("strong",{parentName:"li"},"value_2"),"] will be processed as:\n",(0,l.kt)("strong",{parentName:"li"},"limit_lower")," < std_bound_1 < ",(0,l.kt)("strong",{parentName:"li"},"limit_upper"),",\n-",(0,l.kt)("strong",{parentName:"li"},"value_1")," < std_bound_2 < ",(0,l.kt)("strong",{parentName:"li"},"value_1"),",\n-",(0,l.kt)("strong",{parentName:"li"},"value_2")," < std_bound_2 < ",(0,l.kt)("strong",{parentName:"li"},"value_2"),"."))),(0,l.kt)("li",{parentName:"ul"},"'n_std' : int, default 3\nThe parameter specifies the number of standard deviations to be within limits."),(0,l.kt)("li",{parentName:"ul"},"'nan_passed' : bool, default True\nIf True, the NaN values of standard deviation will pass the test."))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"'mean'"),(0,l.kt)("p",null,"Test whether mean is within the given limits.\nTest parameters are stored as the dict:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"'limits' : float or list, default 1.0\nLimit to test mean. Limits may be set as:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"one value and it will be treated as an +- interval: value -> ","[-value, value]",";"),(0,l.kt)("li",{parentName:"ul"},"list of lower and upper limits: ","[lower_limit, upper_limit]",";"),(0,l.kt)("li",{parentName:"ul"},"If the data has multiple columns, limits may be set for each of the column.\nThat way list length must be equal to number of columns. For example, for the 3-dimensional vector\nwith corresponding mean vector ","[mean_1, mean_2 and mean_3]",":\n[","[",(0,l.kt)("strong",{parentName:"li"},"limit_lower"),", ",(0,l.kt)("strong",{parentName:"li"},"limit_upper"),"]",", ",(0,l.kt)("strong",{parentName:"li"},"value_1"),", ",(0,l.kt)("strong",{parentName:"li"},"value_2"),"] will be processed as:\n",(0,l.kt)("strong",{parentName:"li"},"limit_lower")," < mean_1 < ",(0,l.kt)("strong",{parentName:"li"},"limit_upper"),",\n-",(0,l.kt)("strong",{parentName:"li"},"value_1")," < mean_2 < ",(0,l.kt)("strong",{parentName:"li"},"value_1"),",\n-",(0,l.kt)("strong",{parentName:"li"},"value_2")," < mean_2 < ",(0,l.kt)("strong",{parentName:"li"},"value_2"),"."))),(0,l.kt)("li",{parentName:"ul"},"'nan_passed' : bool, default True\nIf True, the NaN values of the mean will pass the test."))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"'std'"),(0,l.kt)("p",null,"Test whether standard deviation is less then the given limits.\nTest parameters are stored as the dict:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"'limits' : float or list, default 1.0\nLimit to test standard deviation. Limits may be set as:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"one value;"),(0,l.kt)("li",{parentName:"ul"},"If the data has multiple columns, limits may be set for each of the column.\nThat way list length must be equal to number of columns. For example, for the 3-dimensional vector\nwith corresponding standard deviation vectors ","[std_1, std_2, std_3]",":\nlimits = ","[",(0,l.kt)("strong",{parentName:"li"},"value_1"),", ",(0,l.kt)("strong",{parentName:"li"},"value_2"),", ",(0,l.kt)("strong",{parentName:"li"},"value_3"),"]"," will be processed as:\nstd_1 < ",(0,l.kt)("strong",{parentName:"li"},"value_1"),",\nstd_2 < ",(0,l.kt)("strong",{parentName:"li"},"value_2"),",\nstd_2 < ",(0,l.kt)("strong",{parentName:"li"},"value_3"),"."))),(0,l.kt)("li",{parentName:"ul"},"'n_std' : int, default 3\nThe parameter specifies the number of standard deviations to be less then limits."),(0,l.kt)("li",{parentName:"ul"},"'nan_passed' : bool, default True\nIf True, the NaN values of the mean will pass the test."))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"'sid'"),(0,l.kt)("p",null,"Test whether all simulations are within the given limits.\nTest parameters are stored as the dict:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"'limits' : float or list, default 1.0\nLimit to test simulation results. Limits may be set as:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"one value and it will be treated as an +- interval: value -> ","[-value, value]",";"),(0,l.kt)("li",{parentName:"ul"},"list of lower and upper limits: ","[lower_limit, upper_limit]",";"),(0,l.kt)("li",{parentName:"ul"},"If the data has multiple columns, limits may be set for each of the column.\nThat way list length must be equal to number of columns. For example, for the 3-dimensional vector that\ncontains v1, v2, v3 columns and numbers N simulations:\n[","[",(0,l.kt)("strong",{parentName:"li"},"limit_lower"),", ",(0,l.kt)("strong",{parentName:"li"},"limit_upper"),"]",", ",(0,l.kt)("strong",{parentName:"li"},"value_1"),", ",(0,l.kt)("strong",{parentName:"li"},"value_2"),"] will be processed as:\n",(0,l.kt)("strong",{parentName:"li"},"limit_lower")," < v1 < ",(0,l.kt)("strong",{parentName:"li"},"limit_upper"),",\n-",(0,l.kt)("strong",{parentName:"li"},"value_1")," < v2 < ",(0,l.kt)("strong",{parentName:"li"},"value_1"),",\n-",(0,l.kt)("strong",{parentName:"li"},"value_2")," < v3 < ",(0,l.kt)("strong",{parentName:"li"},"value_2")," for each of the N simulations."))),(0,l.kt)("li",{parentName:"ul"},"'nan_passed' : bool, default True\nIf True, the NaN values will pass the test."))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"'norm_L2'"),(0,l.kt)("p",null,"Test whether L2 norm of the each simulation is less than the given limit.\nTest parameters are stored as the dict:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"'limits' : float or list, default 1.0\nLimits on the simulation norm. Limits may be set as:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"one value;"),(0,l.kt)("li",{parentName:"ul"},"if the data has multiple columns, limits may be set for each of the column separately as a list.\nThat way list length must be equal to number of the columns."))))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"'norm_Linf'"),(0,l.kt)("p",null,"Test whether Linf norm of the each simulation is less than the given limit.\nTest parameters are stored as the dict:"),(0,l.kt)("ul",null,(0,l.kt)("li",{parentName:"ul"},"'limits' : float or list, default 1.0\nLimits on the simulation norm. Limits may be set as:",(0,l.kt)("ul",{parentName:"li"},(0,l.kt)("li",{parentName:"ul"},"one value;"),(0,l.kt)("li",{parentName:"ul"},"if the data has multiple columns, limits may be set for each of the column separately as a list.\nThat way list length must be equal to number of the columns."))))),(0,l.kt)("h4",{id:"parameters-6"},"Parameters"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"tests_method"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"dict")),(0,l.kt)("td",{parentName:"tr",align:null},"Keys define test methods and corresponding test parameters are stored as values.")))),(0,l.kt)("h4",{id:"returns-5"},"Returns"),(0,l.kt)("table",null,(0,l.kt)("thead",{parentName:"table"},(0,l.kt)("tr",{parentName:"thead"},(0,l.kt)("th",{parentName:"tr",align:null},"Name"),(0,l.kt)("th",{parentName:"tr",align:null},"Type"),(0,l.kt)("th",{parentName:"tr",align:null},"Description"))),(0,l.kt)("tbody",{parentName:"table"},(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"log"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("a",{parentName:"strong",href:"/docs/data_analysis/documentation/access/citros_dict#access.citros_dict.CitrosDict",title:"access.citros_dict.CitrosDict"},"CitrosDict"))),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with the test results.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"tables"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"dict")),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with test methods as keys and pandas.DataFrame table with results of the test as values.")),(0,l.kt)("tr",{parentName:"tbody"},(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},(0,l.kt)("inlineCode",{parentName:"strong"},"figures"))),(0,l.kt)("td",{parentName:"tr",align:null},(0,l.kt)("strong",{parentName:"td"},"dict")),(0,l.kt)("td",{parentName:"tr",align:null},"Dictionary with test methods as keys and matplotlib.figure.Figure with test results as values.")))),(0,l.kt)("h4",{id:"see-also-2"},"See Also"),(0,l.kt)("p",null,(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"#validation.validation.Validation.std_bound_test",title:"validation.validation.Validation.std_bound_test"},"Validation.std_bound_test()")),", ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"#validation.validation.Validation.mean_test",title:"validation.validation.Validation.mean_test"},"Validation.mean_test()")),", ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"#validation.validation.Validation.std_test",title:"validation.validation.Validation.std_test"},"Validation.std_test()")),", ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"#validation.validation.Validation.sid_test",title:"validation.validation.Validation.sid_test"},"Validation.sid_test()")),", ",(0,l.kt)("strong",{parentName:"p"},(0,l.kt)("a",{parentName:"strong",href:"#validation.validation.Validation.norm_test",title:"validation.validation.Validation.norm_test"},"Validation.norm_test()")))),(0,l.kt)("details",null,(0,l.kt)("summary",null,"Examples"),(0,l.kt)("p",null,"Import Validation and CitrosDB:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> from citros import CitrosDB, Validation\n")),(0,l.kt)("p",null,"From the batch 'density' of the simulation 'diffuse_nebula' from the topic 'A' download 3-dimensional\njson-data 'data.x' that contains 'data.x.x_1', 'data.x.x_2' and 'data.x.x_3' columns,\nand column with time 'data.time'."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> citros = CitrosDB(simulation = 'diffuse_nebula', batch = 'density')\n>>> df = citros.topic('A').set_order({'sid':'asc','rid':'asc'}).data(['data.x','data.time'])\n>>> print(df['data.x'])\n0          {'x_1': 0.0, 'x_2': 0.08, 'x_3': 0.047}\n1       {'x_1': 0.008, 'x_2': 0.08, 'x_3': -0.003}\n2      {'x_1': 0.016, 'x_2': 0.078, 'x_3': -0.034}\n...\n")),(0,l.kt)("p",null,"Set 'data.time' as independent variable and 'data.x' as dependent vector.\n",(0,l.kt)("strong",{parentName:"p"},"method")," defines the method of data preparation and index assignment: method = 'scale' - scales parameter ",(0,l.kt)("strong",{parentName:"p"},"param_label")," for each of the 'sid' to ","[0, 1]"," interval\nand interpolate data on the new scale."),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> V = Validation(df, data_label = 'data.x', param_label = 'data.time',\n...                method = 'scale', num = 50, units = 'm')\n")),(0,l.kt)("p",null,"Test whether 3 standard deviation boundary is within ","[-0.3, 0.3]"," interval (treat nan values of the\nstandard deviation, if they are presented, as passed the test) and L2 norm of the each simulation is less than 12.5:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> logs, tables, figs = V.set_tests(test_method = {\n...                                    'std_bound' : {'limits' : 0.3, 'n_std': 3, 'nan_passed': True},\n...                                    'norm_L2' : {'limits' : 12.5}})\nstd_bound_test: passed\nnorm_test L2: passed\n")),(0,l.kt)("p",null,"Print detailed standard deviation boundary test results:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> logs['std_bound'].print()\n{\n 'test_param': {\n   'limits': 0.3,\n   'n_std': 3,\n   'nan_passed': True\n },\n 'data.x.x_1': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   },\n   'nan_std': {\n     49: 807.942\n   }\n },\n 'data.x.x_2': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   },\n   'nan_std': {\n     49: 807.942\n   }\n },\n 'data.x.x_2': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'failed': {\n   },\n   'nan_std': {\n     49: 807.942\n   }\n  }\n}\n")),(0,l.kt)("p",null,"Print results of norm test in details:"),(0,l.kt)("pre",null,(0,l.kt)("code",{parentName:"pre",className:"language-python"},">>> logs['norm_L2'].print()\n{\n 'test_param': {\n   'limits': 12.5\n },\n 'data.x.x_1': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'norm_value': {\n     1: 0.39,\n     2: 0.38,\n     3: 0.38\n   },\n   'failed': []\n },\n 'data.x.x_2': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'norm_value': {\n     1: 0.38,\n     2: 0.40,\n     3: 0.40\n   },\n   'failed': []\n },\n 'data.x.x_3': {\n   'passed': True,\n   'pass_rate': 1.0,\n   'norm_value': {\n     1: 0.12,\n     2: 0.11,\n     3: 0.12\n   },\n   'failed': []\n }\n}\n"))))}u.isMDXComponent=!0}}]);